import type { CoverageData, CoverageManager, CoverageMetadata, Tag } from "./types.js";
type Line = number;
type Branch = [Line, Tag];
/**
 * @private exposed for testing purposes only
 */
export interface Report {
    [relativePath: string]: {
        tagExecutionCounts: Map<Tag, number>;
        lineExecutionCounts: Map<Line, number>;
        branchExecutionCounts: Map<Branch, number>;
        executedTagsCount: number;
        executedLinesCount: number;
        executedBranchesCount: number;
        partiallyExecutedLines: Set<Line>;
        unexecutedLines: Set<Line>;
    };
}
export declare class CoverageManagerImplementation implements CoverageManager {
    #private;
    /**
     * @private exposed for testing purposes only
     */
    metadata: CoverageMetadata;
    /**
     * @private exposed for testing purposes only
     */
    data: CoverageData;
    constructor(coveragePath: string);
    addData(data: CoverageData): Promise<void>;
    addMetadata(metadata: CoverageMetadata): Promise<void>;
    clearData(id: string): Promise<void>;
    saveData(id: string): Promise<void>;
    report(...ids: string[]): Promise<void>;
    enableReport(): void;
    disableReport(): void;
    /**
     * @private exposed for testing purposes only
     */
    loadData(...ids: string[]): Promise<void>;
    /**
     * @private exposed for testing purposes only
     */
    getReport(): Report;
    /**
     * @private exposed for testing purposes only
     */
    formatLcovReport(report: Report): string;
    /**
     * @private exposed for testing purposes only
     */
    formatRelativePath(relativePath: string): string;
    /**
     * @private exposed for testing purposes only
     */
    formatCoverage(coverage: number): string;
    /**
     * @private exposed for testing purposes only
     */
    formatLines(lines: Set<number>): string;
    /**
     * @private exposed for testing purposes only
     */
    formatMarkdownReport(report: Report): string;
}
export {};
//# sourceMappingURL=coverage-manager.d.ts.map